# Project Report: Library Management System

Generated: 2025-11-10

## Executive summary

This repository is a full-stack Library Management System built with a TypeScript/Node.js backend and a React + Vite TypeScript frontend. Key features:

- User roles (student, librarian, guard, admin)
- QR entry/exit sessions and occupancy tracking (Socket.IO)
- Barcode-based borrowing flow with PDF receipts
- E-book uploads and static serving for e-book files
- Real-time dashboard and notifications

This report documents the project structure, core components, data models, scripts, environment/security notes, and recommended next steps.

---

## Quick facts

- Languages: TypeScript (backend + frontend), some generated JS in `backend/dist`
- Backend: Express, Mongoose (MongoDB), Socket.IO
- Frontend: React (18/19), Vite, TypeScript, Tailwind CSS
- DB: MongoDB (driver via Mongoose)
- Main ports: Backend default 5000, Frontend (Vite) default 5173

---

## Repository layout (high level)

- `backend/` — TypeScript Express API, scripts (seed, generate barcodes/QRs), models, controllers
- `frontend/` — React app (Vite), components, pages, API client
- `PROJECT_REPORT.md` — this file
- `README.md`, `SETUP.md` — docs and setup notes

Key backend subfolders:
- `backend/src/controllers/` — request handlers (auth, books, borrow, session, dashboard, ai)
- `backend/src/models/` — Mongoose models (User, Book, BorrowRecord, Session, Receipt, etc.)
- `backend/src/routes/` — route registration
- `backend/src/utils/` — helpers (auth, jwt, database connect, pdf generation, socket)
- `backend/barcodes/`, `backend/qr-codes/` — generated assets

Key frontend subfolders:
- `frontend/src/components/` — UI components (QRScanner, BarcodeScanner, BookCard, Layout)
- `frontend/src/pages/` — pages (Dashboard, Borrow, Return, History, Admin, AI)
- `frontend/src/api/` — API client wrappers
- `frontend/src/context/` — Auth and Socket contexts

---

## How to run (developer quick start)

1. Backend

```bash
cd backend
npm install
# create or edit backend/config.env (do NOT commit secrets)
npm run dev
```

2. Frontend

```bash
cd frontend
npm install
npm run dev
```

3. Open http://localhost:5173 and ensure backend is running at http://localhost:5000

Notes: the backend `dev` script uses `nodemon` + `ts-node` and compiles to `dist/` on `npm run build`.

---

## Backend deep-dive

Entry point:
- `backend/src/server.ts` — sets up Express, connects to MongoDB via `utils/database`, mounts `/api` routes from `routes/index.ts`, configures static serving for receipts and ebooks, and initializes Socket.IO.

Important utils and behaviors:
- DB connection: `connectDB()` in `backend/src/utils/database.ts` (Mongoose-based)
- Auth middleware: `backend/src/utils/auth.ts` issues an `AuthRequest` typing, validates JWT tokens
- PDF receipts: generated by `utils/pdf` with `generateReceiptPDF()` and stored under `pdf/receipts` then served statically at `/api/receipt/download`.
- Socket IO: `utils/socket` sets up rooms and emits occupancy updates; server sets `io` on the Express app for route access.

Routes and controllers (high level):
- Auth: registration, login, `getMe` — token generation in `utils/jwt` using `JWT_SECRET`.
- Books: add/update/get books, wishlist/reserve, upload e-books — `bookController` uses Mongoose `Book` model.
- Borrow: `borrowController` creates BorrowRecord entries, decrements `copiesAvailable`, generates receipts and optional PDFs; return logic increments availability and marks borrow records returned.
- Session: entry/exit handlers (QR based) that create `Session` documents, track `activeSessionId` on `User`, update `totalHours` and streaks.

Models (summary)
- `User` — fields include name, rollNo (unique), email, password (hashed), role, totalHours, borrowedCount, activeSessionId, wishlist, reserves, streak tracking fields.
- `Book` — barcode (unique), title, authors (string array), copiesTotal, copiesAvailable, description, coverUrl, ebookUrl, sampleUrl.
- `BorrowRecord` — references userId and bookId, borrowedAt, dueAt (14 days default), returnedAt, active flag, receiptId.
- `Receipt` — stores receiptId, userId, borrowIds, issuedAt, tokenHash, valid flag (for one-time verification).
- `Session` — tracks entry/exit, timestamps and computed durations used to update `User.totalHours` and streaks.

Scripts in `backend/package.json`:
- `dev`: nodemon + ts-node for dev
- `build`: tsc
- `start`: node dist/server.js
- `seed`: ts-node seed.ts
- `generate-qr`, `generate-barcodes` — helper asset generation

Dependencies (selected): express, mongoose, socket.io, jsonwebtoken, bcryptjs, qrcode, jsbarcode, pdfkit, multer, cors, dotenv

---

## Frontend deep-dive

Stack & tooling
- Vite + React + TypeScript
- Tailwind CSS for styling, Framer Motion for animations
- API client uses `axios` (likely via `frontend/src/api/client.ts`)

Routing & pages
- `App.tsx` uses React Router with protected routes for core app pages
- Pages include: Dashboard (real-time occupancy + quick actions), Borrow (barcode scan), Return, History, Wishlist, Admin, AI

Key components
- `QRScanner.tsx`, `BarcodeScanner.tsx` — camera-based scanning components using `html5-qrcode` and/or camera APIs
- `BookCard.tsx`, `BookDetailsModal.tsx` — UI for book details
- `PdfImageScanner.tsx` — scanning from PDFs/images (pdfjs usage)
- `ProtectedRoute.tsx` and `AuthContext.tsx` — manage authentication and enforce protected pages

Scripts in `frontend/package.json`:
- `dev`: vite
- `build`: tsc -b && vite build
- `preview`: vite preview
- `lint`: eslint

Dependencies (selected): react, react-dom, react-router-dom, axios, html5-qrcode, pdfjs-dist, socket.io-client, framer-motion

---

## API endpoints (summary)

The backend exposes RESTful endpoints under `/api`.
Selected endpoints:
- Auth
  - POST `/api/auth/register` — register user
  - POST `/api/auth/login` — login (returns JWT)
  - GET `/api/auth/me` — get current user (protected)

- Session (entry/exit)
  - POST `/api/session/entry` — register entry (QR based)
  - POST `/api/session/exit` — register exit (QR based)

- Books
  - GET `/api/books` — list (supports `q` query for search)
  - GET `/api/books/:barcode` — get book
  - POST `/api/books/add` — add book (protected)
  - POST `/api/books/:barcode/upload-ebook` — upload e-book file for a book
  - Wishlist/reserve endpoints (add/remove)

- Borrow/Return
  - POST `/api/borrow` — borrow one or more books (body includes `bookBarcodes` array)
  - POST `/api/return` — return books (body includes `borrowRecordIds`)
  - GET `/api/receipt/verify` — verify a receipt token (one-time use)

- Dashboard
  - Endpoints for occupancy and active sessions

Authentication
- JWT in Authorization header: `Authorization: Bearer <token>`
- `utils/auth` middleware populates `req.user` as `AuthRequest` when valid

---

## Environment variables & security notes

Files discovered:
- `backend/config.env` — contains PORT, MONGODB_URI, JWT_SECRET, NODE_ENV, FRONTEND_URL, and an `OPENAI_API_KEY` value.

Security observations (action required):
- Secrets found in `backend/config.env` (including a DB URI with embedded credentials and an OpenAI API key). Secrets should never be committed to the repo. Action items:
  - Remove `backend/config.env` from source control (add to `.gitignore`) and rotate the exposed credentials immediately.
  - Move secrets to environment variables stored in your deployment platform or a secrets manager (e.g., Azure Key Vault, AWS Secrets Manager, GCP Secret Manager, or at minimum `.env` on server not in Git).
  - Make `config.env` an example file `config.env.example` without secrets for documentation.

- `JWT_SECRET` placeholder: ensure a strong, random `JWT_SECRET` is used in production. Rotate secrets if keys were leaked.

- Rate limiting / brute force: authentication endpoints do not show obvious rate-limiting. Consider adding rate limiting (express-rate-limit) to auth endpoints and other public endpoints.

- Password storage: uses `bcryptjs` — good. Ensure salt rounds are adequate (currently using default in code with genSalt(10)). Consider increasing if threat model demands.

- File uploads: e-book upload endpoints use `multer` and store files under `ebooks/`. Ensure proper file type checks and size limits are applied to avoid arbitrary file uploads and potential DoS.

- CORS: backend enables `cors()` broadly — tighten `origin` in production to the front-end origin.

---

## Code quality & tests

- There are no unit/integration tests in the repository (no `test` script beyond placeholder). Adding tests is strongly recommended.
- TypeScript is used across the stack — good for maintainability.
- Linting: frontend includes ESLint; backend doesn't show an ESLint config in the root of `backend/` (consider adding and enabling pre-commit hooks).

---

## Deployment considerations

- Containerization: create a `Dockerfile` for backend and frontend. Use multi-stage builds for the frontend.
- Build pipeline (CI): set up GitHub Actions or equivalent to run `npm ci`, `npm run build` for both backend and frontend, typecheck, and run any tests.
- Secrets: configure secrets in the CI/CD and runtime environment, do not store in repo.
- Scaling: Socket.IO stateful connections will need sticky sessions or a message broker (Redis adapter) for horizontal scaling.

---

## Suggested immediate improvements (priority ordering)

1. Remove secrets from `backend/config.env` in Git and rotate compromised credentials (high priority).
2. Add `config.env.example` and `.env.example` files documenting required env vars.
3. Add basic tests: unit tests for utils (jwt, pdf, auth) and integration tests for core APIs (auth, borrow, return).
4. Harden upload endpoints with validation and maximum upload size.
5. Add rate limiting to public endpoints (auth, session, borrow) and logging improvements.
6. Add Dockerfiles and a GitHub Actions CI to build, typecheck, and run tests.
7. Add monitoring/alerts (Sentry or similar) for server errors and uptime checks.

---

## Notes on data models and edge cases

Edge cases handled in code:
- Borrow flow checks availability and rolls forward even if PDF generation fails (non-fatal).
- Return flow attempts to update book availability and user counts in a best-effort manner and logs errors without failing the return flow.

Edge cases to consider adding tests for:
- Concurrent borrow requests for same book copies (race condition). Use transactions or optimistic locking.
- Partial failures during borrow (e.g., DB save succeeds then subsequent steps fail). Consider atomic operations or multi-document transactions if using MongoDB replica set.
- Session tracking for entry/exit when incomplete events occur (missing exit or entry).

---

## Where to find things (important files)

- Backend package.json: `backend/package.json` (scripts & deps)
- Backend main: `backend/src/server.ts`
- Backend controllers: `backend/src/controllers/*.ts`
- Backend models: `backend/src/models/*.ts`
- Frontend package.json: `frontend/package.json`
- Frontend entry: `frontend/src/main.tsx`, `frontend/src/App.tsx`
- DB assets: `backend/barcodes/`, `backend/qr-codes/`

---

## Final checklist (what I did)

- Read core backend and frontend files
- Summarized architecture, routes, models, and scripts
- Noted security-sensitive findings and recommended actions
- Created this `PROJECT_REPORT.md` in the repository root

---

## Next steps I can do for you

- Create `backend/config.env.example` and `frontend/.env.example` (no secrets)
- Add a simple `Dockerfile` for backend and a `docker-compose.yml` for local dev
- Add a GitHub Actions CI workflow to typecheck and build
- Add basic unit tests for auth/jwt and borrow logic

Tell me which follow-up you'd like and I'll implement it.
